#CToken 合约文档
目录：
一：合约概述
二：合约状态变量
三：合约核心函数
四：重要机制详解（个人认为这里是首先需要了解的）

## 一：合约概述

### 1.2 合约简介
CToken 是 Compound 协议的 **核心合约**，代表了用户在 Compound 协议中存入资产后 **获得** 的凭证代币。每个 CToken 对应一种特定的底层资产（如 USDC、DAI、ETH 等）。用户存入底层资产后会获得 CToken，这些 CToken 可以用来赎回底层资产、作为借款抵押品，并且会随时间自动累积利息。

### 继承
CToken 继承自：
├── CTokenInterface - CToken 接口定义
├── ExponentialNoError - 指数运算库（无错误版本）
└── TokenErrorReporter - 错误报告器

## 二：合约状态变量
基础变量
关联合约变量
配置参数变量
资产相关变量
用户数据映射变量

## 三：合约核心函数

### 1、ERC-20 代币功能模块
### 2、存款（Mint）模块
### 3、赎回（Redeem）模块
### 4、借款（Borrow）模块
### 5、偿还借款（Repay Borrow）模块
### 6、清算借款（Liquidate Borrow）模块
### 7、利息累积模块
### 8、兑换率与利率查询模块
### 9、管理员功能模块
### 10、虚拟函数（需要子合约实现
### 11、重入防护
### 12、未知模块（以后更新这些函数的作用）

## 四：重要机制详解
首先的了解几个公式：
资金使用率：`U = totalBorrows / (totalCash + totalBorrows - totalReserves)`
借贷利率:不方便写公式，各位可以去查以下百度，你也可以看我的 **compound学习文章：https://github.com/Z2316914847/foundry_Study/blob/main/task/day12/article/compound%E5%AD%A6%E4%B9%A0.md**
存款利率：同上
结算总还款和总存款：同上

### 1、兑换率的作用
兑换率 决定了 CToken 和 底层资产 之间的兑换比例，是 Compound 协议实现 **存款收益** 的核心机制。
APY计算方式：（最新利息-上一次利息）/上一次利息

### 2、利息累积
怎么理解利息累计呢？要明白这个，首先的明白，利率是 **细分** 到区块上的：这样理解，在defi领域，利率是 **细分** 到区块上的：假如 年华利率20%，假如每一个小时出一个区块，那么每个区块利率 = 20% / (1 * 24 * 365) = 0.0000228 = 0.00228%。然后用户在借款、存款、还款时，会计算出从开始借款 - 还款这个期间的区块总利息，然后compound会结算利息，并将利息归到用户借贷金额中。
利息累积计算方式；borrowIndexNew = **borrowIndex** + **borrowIndex** x borrowRate × blockDelta

### 3、借贷余额计算
因为已经计算出了 **利息累计**，现在我们就计算借贷余额
计算方式：总欠款（借贷本金+利息） =  借款本金 × (当前累计利息 / 借款时的累计利息)

### 清算
借款价值 > 抵押品价值 × 抵押率
清算激励
  清算奖励5%-8%，其中协议会从清算奖励中抽取2.8%给协议储备金，所以清算人实际获得清算奖励为 2.2%-5.4%
- **清算折扣**: 通常为 8%，清算人以 92% 的价格获得抵押品
- **协议分成**: 清算所得的一部分（如 2.8%）归协议储备金

### 4、安全机制
ctoken严格遵守 检查-效果-交互模式
所有关键函数都使用 `nonReentrant` 修饰符，防止递归调用。
新鲜度检查：确保操作基于最新的利息累积状态（ require(accrualBlockNumber == getBlockNumber(), "Market not fresh") ）。
控制器检查：所有核心操作都需要通过控制器的授权：
  - `comptroller.mintAllowed()`
  - `comptroller.borrowAllowed()`
  - `comptroller.redeemAllowed()`
  - `comptroller.liquidateBorrowAllowed()`
Solidity 0.8+ 内置溢出检查，所有算术操作自动检查溢出。


# 走进 Ctoken
## initialize
最出的ctoken池子必定没人存款借款等等，一切都是最初的状态（我指的是状态变量）然后有人部署ctoken后的一瞬间：
- 管理员地址 = 部署ctoken的人 的地址    √
- 风险控制器 = 最新部署的合约           √
- 利率模型 = 最新部署的合约             √
- 每个区块最大借贷利率（不可变） = 0.0005e16 = 0.00005%       √
- 最大储备金系数（不可变） = 1e18 = 100e16 = 100%             √
- 协议清算分层 = 0.028e18 = 2.8e16 = 2.8%                    √
- 兑换率 = 0.02e18 = 2%           √
- 储备金系数 = 0.1e18 = 10%       为什么ctoken初始化不设置 储备金系数
- 记息区块 = block.number         √
- 累计利息 = 1e18                 √
- 借贷金额 = 0
- 储备金   = 0
- 总供应量 = 0
- 重入锁   = true

## transfer
1、CToken 是抵押品，不是普通代币，你不能随意转移作为贷款抵押的质押物，因为这会影响到 compound 的资产质量和风险控制。
2、为什么compound中的ctoken转账函数有四个参数，而普通erc20转账只有三个参数。
- 答：一个函数处理两种转账场景（普通转账、被授权人使用津贴进行转账）、明确区分调用者和发送方
3、为什么转账需要检查
- 防止市场被停止
  - 维持系统稳定
    - 假如某一时刻用质押物暴跌50%，导致很多用户质押率不足，大量清算人清算借贷，这就会进一步质押物价格下跌（这个过程清算人可能也不盈利），这样就会给系统带来清算压力过大，形成恶性螺旋，最终导致系统崩溃。
  - 暂停市场会限制这些功能：转账、借贷、清算。其他功能能正常使用。
- 防止用户逃离清算: 大致意思是,用户转移代币价值 + 借贷价值 > 质押价值,这是协议形成坏账.所以转账时要检查,以防止用户逃离清算.
4、转账时的检查 代码逻辑
- 检查市场是否被停止
- 计算用户转移代币后,账户健康度
- Comp代币分发(Comp代币时治理代币), 
  - 为什么要分发Comp治理代币
    - 激励流动性供应
    - 去中性化治理
    - 价值捕获: 协议越成功 -> COMP治理代币 需求高 -> COMP治理代笔 价值推高
  - 分发 Comp治理代币逻辑
    - 每天总发放: 2,880 COMP => 每秒发放: 0.0333 COMP
    - 分配规则: 
    50% (1,440 COMP/天) → 供应者（存款人）
    50% (1,440 COMP/天) → 借款人
    - 各市场独立分配,例如: 
    cUSDC: 1000 COMP/天 → 供应者
    cDAI:  800 COMP/天  → 供应者
  - 用户应得 COMP = 用户持有 cToken × (当前指数 - 用户上次快照指数)
  - COMP治理代币 分发时机
    - mint()        - 存款
    - redeem()      - 取款
    - borrow()      - 借款
    - repayBorrow() - 还款
    - transfer()    - 转账



