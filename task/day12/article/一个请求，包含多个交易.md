一个请求，包含多个交易

- permit

- multicall

  - 循环使用低级别调用

- 交易信息结构设置为：EIP-7702标准格式

  ```
  // 1.构建请求
  const approveCalldata = encodeFunctionData({
              abi: TOKEN_ABI,
              functionName: 'approve',
              args: [TOKENBANK_ADDRESS, DEPOSIT_AMOUNT],
            });
  const depositCalldata = encodeFunctionData({
              abi: TOKENBANK_ABI,
              functionName: 'deposit',
              args: [DEPOSIT_AMOUNT],
          });
  // 2.将请求包装
  const calls = [
              {
                  to:TOKEN_ADDRESS,   // 合约地址
                  data:approveCalldata,  // 合约方法调用
                  value: BigInt(0),
              },
              {
                  to:TOKENBANK_ADDRESS ,
                  data:depositCalldata,
                  value: BigInt(0),
              }
          ];
  
  // 3.构建7702消息需要的数据： authorization_list   ＋  将用户设置为智能合约  也就是说这个合约获得用户授权
  const authorization = await walletClient.signAuthorization({
              account: eoa,
              contractAddress: DELAGATE_ADDRESS,
              executor: 'self', 
          }); 
  // 4. 发送 EIP-7702 交易
  const executeHash = await walletClient.writeContract({
              account: eoa, 
              abi: DELAGATE_ABI,
              address:eoa.address,   // 设置为账户的智能合约地址
              functionName: 'execute',
              args: [calls],
              authorizationList: [authorization],
          });
  ```

- ### 客户端批量签名 (Flashbots 等 MEV 服务)

  这种方法主要用于高级用户和MEV场景。

  - **工作原理**：

    1. 用户在本地创建多个独立的、签名的交易。
    2. 用户将这些交易作为一个“捆绑包”提交给Flashbots之类的中继器。
    3. 中继器将整个捆绑包传递给区块构建者。
    4. 区块构建者将这个捆绑包中的所有交易按顺序放入同一个区块中。

  - **优点**：

    - **无需新合约**：不需要部署任何智能合约。
    - **抗MEV**：可以防止在公共内存池中被抢跑或三明治攻击。
    - **兼容任意交易**：捆绑包中可以包含任何类型的交易。

    **缺点**：

    - **非原子性**：如果捆绑包中的某个交易失败，**其他交易仍然会被执行**。它不具备智能合约批处理的原子回滚特性。
    - **复杂性高**：对普通用户极不友好，需要与特定的RPC端点交互并理解捆绑包的概念。
    - **依赖第三方**：依赖于中继器和区块构建者的合作。