# compound学习

## 一、理论基础

### 传统金融借贷逻辑 VS DEFI 借贷逻辑

银行如何决定利率

去中心化借贷的供需平衡机制（算法化利率）

### 借贷协议的经济角色

流动性提供者

借贷人

协议作为中间层（匹配与风险调节）

### Uniswap 和 compound对比

Uniswap = 即时交换流动性

compound = 时间维度的流动性

## 二、 经济模型

模块：利用率、借贷利用率、存款利用率、抵押利用率、清算触发条件

为什么借贷协议会自动形成 ” 动态平衡 “

### 1、利率模型

 #### 借贷和存款利率计算（这里☞的是：只有一次借贷或者存款，后续用户不进行借贷或者存款）

首先的明白：**利率 **是实时动态变化的，这个变化与 **资金的使用率** 变化有关。

- 资金使用率

  - U = Total Borrows / ( Total cash + Total Borrows + Reserves ) 
    - U：资金的使用率
    - Total Borrows ：当前池子总借款数额
    - Total cash：还未借出的金额
    - Reserves：协议预留的资金（不能借出）
  - 假如某用户向池子存款价值 1000U 的资产，现在用户借出 800U，协议储备 20U，那么 U = 800 / ( 200 + 800 - 20 ) = 81.6%，**现在用户的 资金使用率是81.6%**。这个用户 资金使用率会影响利率（只影响自己的利率，不会影响他人），意思就是这个资金使用率会影响 **用户 借款利息**。

- 利率（利息）

  不同平台 资金使用率临界点 不一样，看平台自己设计，compound资金使用率临界点（K）是80%

  利率计算涉及的参数：baseRate = 2%，multiplier = 20%，K = 80%，jumpMultiplier = 150%，reserveFator = 10%

  - **借贷人利率计算**
    - U <= 80%
      -  borrowsRate = baseRate + U * multiplier 
    - U >  80%
      - borrowsRate = baseRate + kink *  multiplier +（ U - kink ）* jumpMultiplier
  - **存款人利率计算**（这个我经常忘记，下次就这样记：存款人利率 和 资金使用率有关，**成正比**）
    - supplyRate = borrowsRate * U * ( 1- reserveFator )

#### 借贷和存款  *收益*   计算（ 重点：借贷人收益 = 借贷金额 + 利息、存款人收益 = 存款金额 + 利息 ）

利率是实时的，想必大家都知道。在现实生活在，用户来借贷，有时候不知借贷一次，会借款多次，并且用户借贷后肯定还会还款，这样的动作都会导致资金使用率变化，进而导致 利率 变化。所以要怎么计算 ***借贷人 和 存款人*** 的 **收益** 呢？答：比知道 sushi 的奖励分配机制吗，借款人和存款人收益计算 和 sushi 的奖励分配机制类似。都是使用 **累计** 计算收益。

##### 借贷人收益计算（其实是利息）

首先得明白：在defi领域，利率是 **细分** 到区块上的：假如 年华利率20%，假如每一个小时出一个区块，那么每个区块利率 = 20% / (1 * 24 * 365) = 0.0000228 = 0.00228%

###### 我的理解：收益计算方式

- 总收益 = 上一次总收益 + 上一次总收益 * 每个区块的利率 * 区块增加量

  borrows_New = borrows_old +   borrows_old * block_Rate * block_acount

```
举一个例子：用户存入价值1000U得资产，然后借出 200U,经过10个区块后，用户还100U，在经过10个区块后，还掉所有借贷。 假如：baseRate = 2%，multiplier = 20%，K = 80%，jumpMultiplier = 150%，reserveFator = 10%。可以计算出如下结果 
  资金使用率 = 200 / (800 + 200 - 20) ≈ 20.41%
  利率 = 2% +  20.41% * 20% = 2% + 4.08% = 6.08%
  每个区块利率 = 6.08% / ( 1 * 24 * 365 ) = 0.0000069406 = 0.00069406%
  10个区块总收益 = 200 + 200 * 0.00069406% * 10 = 200 + 0.0138812
  
  因为还款100U会触发资金使用率变化-》利率变化
  注意用户还款100U，时先支付利息，剩余部分还借贷，所以
  注意：利息最终会归入协议储备中：利息 * reserveFator,为了方便，这里暂时不考虑协议储备
  资金使用率 = 100.0138812 / (900 + 100.0138812 - 20) ≈ 10.21%
  利率 = 2% +  10.21% * 20% = 2% +2.042% = 4.042%
  每个区块利率 = 4.042% / ( 1 * 24 * 365 ) = 0.000004614 = 0.0004614% * 10 =
  20个区块总收益 = 100.0138812 + 100.0138812 * 0.0004614% * 10 = 100.0138812 + 0.0044615 ≈ 100.0185
  
  再次经过10个区块，也就是在第20个区块时，用户还需要支付 100.0185U 才能还清借贷。首先支付0.0044615利息，然后支付 100.0138812 还借贷。 
```

###### 官方计算方式

- 总还款 = 上一次借贷金额 * 最新借贷利息累计系数 / 上一次借贷利息系数

  最新借贷利息累计系数  = 上一次借贷利息系数（ 1 + 每个区块的利率 * 区块增加量 ）

  currentBorrow = principal * borrowIndex_New / accountBorrowIndex

  borrowIndex_New =  borrowIndex_Old * ( 1 + Bolck_Rate * Block_acount  )

  ```
  200 + 0.0138812还是上面那个例子：可以计算出如下结果 
    资金使用率 = 200 / (800 + 200 - 20) ≈ 20.41%
    利率 = 2% +  20.41% * 20% = 2% + 4.08% = 6.08%
    每个区块利率 = 6.08% / ( 1 * 24 * 365 ) = 0.0000069406 = 0.00069406%
    10个区块最新借贷利息累计系数 = 1 + 1 * 0.00069406% * 10 = 1 + 0.000069406
    10个区块后总收益 = 200 * 1.000069406 / 1 = 200.0138812
    
    为了方便，这里暂时也不考虑协议储备
    资金使用率 = 100.0138812 / (900 + 100.0138812 - 20) ≈ 10.21%
    利率 = 2% +  10.21% * 20% = 2% +2.042% ≈ 4.042%
    每个区块利率 = 4.042% / ( 1 * 24 * 365 ) ≈ 0.000004614 ≈ 0.0004614% 
    10个区块最新借贷利息累计系数 = 1.000069406 + 1 * 0.0004614% * 10  ≈ 1.000069406 + 0.00004614  ≈ 1.00011552
    20个区块总收益 = 100.0138812 * 1.00011552 / 1.000069406  ≈ 100.018493
    
  ```

##### 存款人收益计算

首先介绍官方概念：存款人利息是通过cToken来体现的，而cToken是存入资产凭证，也是生息代币。每一种 **借贷资产** 都有对应的一种cToken，比如，ETH 对应cETH，USDT 对应 cUSDT，生息体现为 cToken 与 Token 的兑换比例不断变大。

本人表达：用户存入资产ETH到池子中，不是单纯的将资产放进去而已，而是存入ETH后到池子后，用户将获得池子中存入凭证，这个凭证就是cETH，这个cETH代表你在池子中的份额。在底层这个 cETH和ETH 之间是有汇率（exchangeRate），当汇率上升，存款人收益便会上升。

有人会问，汇率为什么会上升。答：因为存款人利率 = borrowsRate * U * ( 1- reserveFator )，又因为当有人借贷时，那么资金使用率便会上升，进而 借贷利率也会上升，这样汇率也会上升。

###### 我的理解：收益计算方式

- 新的汇率 = 上一次汇率 + 上一次汇率 * 每个区块的利率 * 区块增加量

  exchangeRate_New =  exchangeRate_Old + exchangeRate_Old * block_Rate * block_acount

  将得到的 Token = 新的汇率 * 手中持有的 cToken 数量

###### 官方计算方式

- 新的汇率 = （池子内当前底层资产余额 + 所有借款人的总借款额 - 协议存储 ）/ 已发行的cToken总量

  将得到的 Token = 新的汇率 * 手中持有的 cToken 数量

  exchangeRate = （cash + totalBorrows - totalReserves）/ totalSupply

### 2、储备金模式

从 利息中抽取资金 作为协议收入，compound从利息中 抽取10% 作为协议收入

### 3、激励机制

向存款人和借款人发送 Comp代币奖励，以此增加流动性参与度。

每个区块产生固定数量的comp代币。

### 4、风险参数和清算模型

控制资产抵押率（借贷上限，比如最多可以 借出 存入资产的75% 额度）

清算机制：借款价值> 质押价值 * x%时触发清算，清算奖励通常在 5% - 8%

## 三、系统架构

### 1、Comptroller（风险中心+资产管理）



### 2、cToken（资产池）



### 3、InterestRateodel（动态利率计算）



### 4、PriceOracle（价格预言机）

- 获取 Chainlink price feeds 或其他数据源

- Compound Labs 运营的 “Poster”账户 将价格定期签名并发布到合约 [(open-oracle)](https://github.com/compound-finance/open-oracle)

- 获取价值时使用 oracle.getUnderlyingPrice(cToken): 使用 ETH 币本位

- Compound 的 Comptroller 是一个统一的风险控制器: 在用户借款、赎回、清算时统计资产价值总额

  图片链接：C:\Users\28448\AppData\Roaming\Typora\typora-user-images\1760955883957.png

  ![1760955883957](C:\Users\28448\AppData\Roaming\Typora\typora-user-images\1760955883957.png)

### 5、Governance（治理）



## 四、智能合约源码

cToken -> Comptroller -> InterestRateodel -> PriceOracle -> Governance

## 五、清算和风险控制

### 账户健康度



### 清算过程



### 安全机制

reseverFactor：防止利息分配过高

closeFactor：每次清算最大偿还比例

Comptroller：检查所有调用权限

## 六、治理与升级

### COMP代币的投票机制

### GovernorAlpha -> Bravo 架构

### TimeLock 延迟执行机制



## 七、扩展与对比研究

### Aave

### Morpho

